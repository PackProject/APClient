#!/usr/bin/env python3

# =============================================================================#
#                                                                              #
# Kokeshi Ninja utilities                                                      #
#                                                                              #
# =============================================================================#

import subprocess
import sys
from glob import glob
from io import StringIO
from os import walk
from os.path import abspath, isdir
from os.path import join as joinpath
from os.path import split, splitext

from .ninja_syntax import Writer

# =============================================================================#
# Configuration                                                                #
# =============================================================================#

NINJA_REQUIRED_VERSION = "1.11"
WINDOWS_EXECUTABLE_EXTENSION = ".exe"
CONFIGURE_SCRIPT = "configure.py"
CHECKROM_SCRIPT = "checkrom.py"

# =============================================================================#
# Utilities                                                                    #
# =============================================================================#


class PathObj:
    """Represents a file in the project.
    """

    def __init__(self, parent: "KokeshiProject", path: str):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            path (str): File path
        """

        self._parent = parent
        self._path = path
        self._base_path = splitext(self._path)[0]
        self._dir_path = split(self._path)[0]

    def path(self) -> str:
        """Gets the path to this file
        """

        return self._path

    def directory(self) -> str:
        """Gets the path to the directory containing this file
        """

        return self._dir_path

    def with_extension(self, extension: str) -> str:
        """Applies the specified file extension to this file path.
        `Ex: "source.cpp" -> "source.o"`

        Args:
            extension (str): File extension
        """

        return f"{self._base_path}{extension}"


class CompileUnit(PathObj):
    """Represents a translation/compilation unit in the project.
    """

    def __init__(self, parent: "KokeshiProject", src_path: str):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            src_path (str): Source file path
        """

        super().__init__(parent, src_path)

    def object_path(self) -> str:
        """Gets the path to the object file generated by this translation unit
        """

        return joinpath(
            self._parent.build_dir,
            self.with_extension(".o"))

    def dependency_path(self) -> str:
        """Gets the path to the dependency file generated for this translation unit
        """

        return joinpath(
            self._parent.build_dir,
            self.with_extension(".d"))

    def output_directory(self) -> str:
        """Gets the path to the directory containing the object file generated by this translation unit
        """

        return joinpath(
            self._parent.build_dir,
            self.directory())


class KamekBinary(PathObj):
    """Represents a Kamek binary in the project.
    """

    def __init__(self, parent: "KokeshiProject", pack: str, name: str,
                 static_addr: int = 0):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            pack (str): Pack Project target
            name (str): Binary name
            static_addr (int): Static code destination memory address
        """

        pack_case = pack.capitalize()

        self._rel_path = joinpath(parent.build_dir, f"{name}{pack_case}.bin")
        super().__init__(parent, self._rel_path)

        self._pack = pack
        self._name = name
        self._static_addr = static_addr

    def pack(self) -> str:
        """Gets the target Pack Project game of this module
        """

        return self._pack

    def name(self) -> str:
        """Gets the name of this module
        """

        return self._name

    def static_addr(self) -> int:
        """Gets the virtual address at which the static code should be loaded
        """

        return self._static_addr

    # =============================================================================#
    # Build artifacts                                                              #
    # =============================================================================#

    def static_build_path(self) -> str:
        """Gets the path to the static code module generated for this binary
        """

        # Not all Kamek binaries require DOL patches
        if self._static_addr == 0:
            return None

        return joinpath(self._parent.build_dir,
                        f"{self._name}{self._pack.capitalize()}Static.dol")

    def rel_build_path(self) -> str:
        """Gets the path to the relocatable code module generated for this binary
        """

        return self._rel_path

    def map_build_path(self) -> str:
        """Gets the path to the symbol map generated for this binary
        """

        return PathObj(self._parent, self._rel_path).with_extension(".map")

    # =============================================================================#
    # Installation artifacts                                                       #
    # =============================================================================#

    def static_install_path(self) -> str:
        """Gets the path to the static code module installed for this binary
        """

        # Not all Kamek binaries require DOL patches
        if self._static_addr == 0:
            return None

        return joinpath(self._parent.romfs_dir, self._pack,
                        "DATA", "sys", "main.dol")

    def rel_install_path(self) -> str:
        """Gets the path to the relocatable code module installed for this binary
        """

        return joinpath(self._parent.romfs_dir, self._pack,
                        "DATA", "files", self._parent.modules_dir,
                        f"{self._name}{self._pack.capitalize()}.bin")

    def map_install_path(self) -> str:
        """Gets the path to the symbol map installed for this binary
        """

        return PathObj(self._parent, self.rel_install_path()).with_extension(".map")

    # =============================================================================#
    # Misc. attributes                                                             #
    # =============================================================================#

    def symbols_path(self) -> str:
        """Gets the pack to the base DOL symbols required by this binary
        """

        return joinpath(self._parent.base_dir,
                        f"Symbols{self._pack.capitalize()}.txt")

    def baserom_path(self) -> str:
        """Gets the path to the base DOL file patched for this binary
        """

        return joinpath(self._parent.base_dir,
                        f"Static{self._pack.capitalize()}.dol")

    def linker_flags(self):
        """Gets a set of flags for the Kamek linker
        """

        flags = " ".join([
            f"-output-kamek={self._rel_path}",
            f"-output-map={self.map_build_path()}",
            f"-externals={self.symbols_path()}"
        ])

        if self._static_addr != 0:
            flags = " ".join([
                f"-static={hex(self._static_addr)}",
                f"-input-dol={self.baserom_path()}",
                f"-output-dol={self.static_build_path()}",
                flags
            ])

        return flags


class KamekLoader(KamekBinary):
    """Represents a loader (statically-linked) Kamek binary.
    """

    def __init__(self, parent: "KokeshiProject", pack: str):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            pack (str): Pack Project target
        """

        super().__init__(
            parent=parent,
            pack=pack,
            name="Loader",
            static_addr=parent.static,
        )


class KamekModule(KamekBinary):
    """Represents a user module (dynamically-linked) Kamek binary.
    """

    def __init__(self, parent: "KokeshiProject", pack: str,
                 name: str = None):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            pack (str): Pack Project target
            name (str): Module name (defaults to "Module")
        """

        super().__init__(
            parent=parent,
            pack=pack,
            name=name or "Module",
        )


class Asset(PathObj):
    """Represents an asset resource file.
    """

    def __init__(self, parent: "KokeshiProject", pack: str,
                 path: str):
        """Constructor

        Args:
            parent (KokeshiProject): Parent project
            pack (str): Pack Project target
            path (str): Asset file path
        """

        super().__init__(parent, path)

        self._pack = pack

    def pack(self) -> str:
        """Gets the target Pack Project game of this asset
        """

        return self._pack

    def install_path(self):
        """Gets the ROM path where this asset should be installed
        """

        asset_dir = joinpath(self._parent.assets_dir, self._pack)

        install_dir = joinpath(self._parent.romfs_dir,
                               self._pack, self._parent.romfs_asset_dir)

        # Asset paths map 1:1 from asset directory to romfs
        return self.path().replace(asset_dir, install_dir)


def find_files(root_path: str, extensions: list[str] = None) -> list[str]:
    """Searches recursively from the root path for all files matching any of the specified file extensions.
    If no extensions are specified, all files are allowed.

    Args:
        root_path (str): Root search path
        extensions (list[str]): File extensions

    Returns:
        list[str]: All files matching the specified conditions
    """

    found = []

    for dirpath, _, filenames in walk(root_path):
        for name in filenames:
            # Ignore hidden files
            if name.startswith("."):
                continue

            _, ext = splitext(name)

            if not extensions or ext in extensions:
                found.append(joinpath(dirpath, name))

    # Alphabetical order
    found.sort()
    return found


def find_directories(root_path: str, recursive: bool) -> list[str]:
    """Searches from the root path for all subdirectories.
    The `recursive` argument controls whether the search recurses into subdirectories.
    The root path (`root_path`) is included in the list of results.

    Args:
        root (str): Root search path
        recursive (bool): Whether to recurse into subdirectories

    Returns:
        list[str]: All subdirectories
    """

    found = [root_path]

    for dirpath, dirnames, _ in walk(root_path):
        found += [joinpath(dirpath, x) for x in dirnames]

        if not recursive:
            break

    return found


def emit_compile_unit(writer: Writer, unit: CompileUnit,
                      cflags_var: str, precompile: list[str] = []):
    """Emits a Ninja build target for a translation unit in the project.

    Args:
        writer (Writer): Ninja writer
        unit (CompileUnit): Source file translation unit
        cflags_var (str): Compiler flags to use as the `$cflags` variable
        precompile (list[str]): List of precompiled headers this translation unit depends on
    """

    if precompile:
        raise ValueError("Precompiled headers not supported yet :(")

    writer.build(
        outputs=unit.object_path(),
        rule="CC",
        inputs=unit.path(),
        variables={
            "depfile": unit.dependency_path(),
            "cflags": cflags_var,
            "outdir": unit.output_directory(),
        },
        implicit=precompile
    )


def emit_link_binary(writer: Writer, binary: KamekBinary,
                     units: list[CompileUnit]):
    """Emits a Ninja build target for linking a Kamek binary in the project.

    Args:
        writer (Writer): Ninja writer
        binary (KamekBinary): Kamek binary
        units (list[CompileUnit]): Translation/compilation units to include in the binary
    """

    inputs = [unit.object_path() for unit in units]
    outputs = [binary.rel_build_path(), binary.map_build_path()]

    # Some Kamek binaries (like the loader) require DOL patches
    if binary.static_build_path():
        outputs.append(binary.static_build_path())

    writer.build(
        outputs=outputs,
        rule="LD",
        inputs=inputs,
        variables={
            "ldflags": binary.linker_flags(),
            "name": binary.name(),
            "pack": binary.pack(),
        },
        implicit=binary.symbols_path()
    )


def emit_install_binary(writer: Writer, binary: KamekBinary):
    """Emits a Ninja build target for installing a Kamek binary in the project.

    Args:
        writer (Writer): Ninja writer
        binary (KamekBinary): Kamek binary
    """

    # Some Kamek binaries (like the loader) require DOL patches
    if binary.static_addr() != 0:
        input_bin = binary.static_build_path()
        output_bin = binary.static_install_path()
    else:
        input_bin = binary.rel_build_path()
        output_bin = binary.rel_install_path()

    input_map = binary.map_build_path()
    output_map = binary.map_install_path()

    writer.build(
        outputs=[output_bin, output_map],
        rule="install_binary",
        inputs=[input_bin, input_map],
        variables={
            "bin_in": input_bin,
            "bin_out": output_bin,
            "map_in": input_map,
            "map_out": output_map,
            "name": binary.name(),
            "pack": binary.pack(),
        },
    )


def emit_install_asset(writer: Writer, asset: Asset):
    """Emits a Ninja build target for installing an asset in the project.

    Args:
        writer (Writer): Ninja writer
        asset (Asset): Project asset
    """

    writer.build(
        outputs=asset.install_path(),
        rule="install_asset",
        inputs=asset.path(),
        variables={
            "pack": asset.pack(),
        },
    )

# =============================================================================#
#                                                                              #
# Project interface                                                            #
#                                                                              #
# =============================================================================#


class KokeshiProject:
    """Represents the Kokeshi build configuration.
    Edit any public members before committing the Ninja build script with `emit()`.
    """

    def __init__(self):
        """Constructor
        """

        self.static = 0x80001900
        self.packs = []

        self.cflags_common = []
        self.cflags_module = []
        self.cflags_debug = []
        self.cflags_release = []

        self.use_git_commit_hash = False
        self._git_commit_hash = ""

        self.assets_dir = "assets"
        self.base_dir = "base"
        self.docs_dir = "docs"
        self.build_dir = "build"
        self.romfs_dir = "romfs"
        self.romfs_asset_dir = "DATA\\files"
        self.modules_dir = "modules"
        self.include_dir = "include"
        self.library_dir = "lib"
        self.loader_dir = "loader"
        self.src_dir = "src"
        self.tools_dir = "tools"

        self.compiler = "codewarrior\\mwcceppc.exe"
        self.linker = "kamek\\Kamek"

        self.source_extensions = [".c", ".cpp", ".cc", ".cxx", ".c++"]

        self._cflags_common_internal = [
            # For Kokeshi-specific code (separate from decomp)
            "-D__KOKESHI__",

            "-I-",
            "-inline auto",          # Auto-inline small functions
            "-proc gekko",           # Gekko processor
            "-Cpp_exceptions off",   # Disable C++ exceptions
            "-enum int",             # Force 4-byte enumerations
            "-O4,s",                 # Max optimization level, focus on small code size
            "-use_lmw_stmw on",      # Use lmw/stmw for stack frames to save code size
            "-fp fmadd",             # Use compact floating-point instructions to save code size
            "-rostr",                # Place strings in rodata
            "-RTTI off",             # Disable RTTI to save module size
            "-sdata 0",              # We can't use small data sections in relocatable code
            "-sdata2 0",             # We can't use small data sections in relocatable code
            "-pragma \"cpp1x on\"",  # Enable C++11 features
            "-DREVOLUTION",          # For BTE library
        ]
        self._cflags_module_internal = []
        self._cflags_debug_internal = []
        self._cflags_release_internal = [
            "-DNDEBUG",
        ]

        self._cflags_include_internal = []

    def emit(self) -> None:
        """Emits the Ninja build script (`build.ninja`)
        """

        # Prepare fields that may change from user configuration
        self._proc_before_emit()

        output = StringIO()
        writer = Writer(output)

        # Variables
        self._emit_vars(writer)

        # Rules
        self._emit_rules(writer)

        # Build targets
        self._emit_targets(writer)

        # Create ninja script
        with open("build.ninja", "w+") as f:
            f.write(output.getvalue())

        writer.close()

    def _proc_before_emit(self) -> None:
        """Evaluates any variables after user configuration, but before emitting the Ninja build script
        """

        # Create flags for the defined pack(s)
        self._cflags_common_internal.extend(
            [f"-DPACK_{pack.upper()}" for pack in self.packs])

        # Include directory priority
        include_dir_order = [
            joinpath(self.include_dir, "MSL"),
            self.src_dir,
            self.include_dir,
            self.library_dir,
            self.loader_dir,
        ]

        # Create compiler flags for includes
        for dir in include_dir_order:
            for sub_dir in find_directories(dir, recursive=False):
                self._cflags_include_internal.append(f"-ir {sub_dir}")

        # Create compiler flag for Git commit hash
        if self.use_git_commit_hash:
            result = subprocess.run(
                ["git", "rev-parse", "--short", "HEAD"],
                capture_output=True,
                check=True
            )

            short_hash = result.stdout.decode("utf-8").replace("\n", "")
            self.cflags_module.append(f"-DGIT_COMMIT_HASH={short_hash}")

    def _emit_vars(self, writer: Writer) -> None:
        """Emits the variables section of the Ninja build script

        Args:
            writer (Writer): Ninja writer
        """

        writer.comment("==================================================")
        writer.comment("Variables")
        writer.comment("==================================================")

        # Ninja requirements
        writer.comment("Ninja requirements")
        writer.variable("ninja_required_version", NINJA_REQUIRED_VERSION)
        writer.newline()

        # Directories
        writer.comment("Directories")
        writer.variable("assets_dir",      self.assets_dir)
        writer.variable("build_dir",       self.build_dir)
        writer.variable("base_dir",        self.base_dir)
        writer.variable("romfs_dir",       self.romfs_dir)
        writer.variable("romfs_asset_dir", self.romfs_asset_dir)
        writer.variable("modules_dir",     self.modules_dir)
        writer.variable("include_dir",     self.include_dir)
        writer.variable("library_dir",     self.library_dir)
        writer.variable("loader_dir",      self.loader_dir)
        writer.variable("src_dir",         self.src_dir)
        writer.variable("tools_dir",       self.tools_dir)
        writer.newline()

        # Tools
        writer.comment("Tools")
        writer.variable("cc",        self._win_tool_cmd(self.compiler))
        writer.variable("ld",        self._tool_path(self.linker))
        writer.variable("configure", abspath(CONFIGURE_SCRIPT))
        writer.variable("python",    sys.executable)
        writer.newline()

        # Flags
        writer.comment("Flags")
        writer.variable("cflags_common", " ".join([
            *self._cflags_common_internal,
            *self.cflags_common,
            *self._cflags_include_internal,
        ]))
        writer.newline()

        writer.variable("cflags_module", " ".join([
            *self._cflags_module_internal,
            *self.cflags_module,
        ]))
        writer.newline()

        writer.variable("cflags_debug", " ".join([
            *self._cflags_debug_internal,
            *self.cflags_debug
        ]))
        writer.newline()

        writer.variable("cflags_release", " ".join([
            *self._cflags_release_internal,
            *self.cflags_release
        ]))
        writer.newline()

        writer.variable("cflags_include", " ".join([
            *self._cflags_include_internal
        ]))
        writer.newline()

    def _emit_rules(self, writer: Writer) -> None:
        """Emits the build rules section of the Ninja build script

        Args:
            writer (Writer): Ninja writer
        """

        writer.comment("==================================================")
        writer.comment("Rules")
        writer.comment("==================================================")

        # # Precompile header file
        # writer.comment("Precompile header file")
        # writer.rule(
        #     name="PCH",
        #     command="$wrapper $cc $cflags -c $in -precompile $out",
        #     depfile="$depfile",
        #     deps="gcc",
        #     description="PRECOMPILE $in",
        # )
        # writer.newline()

        # Compile source file
        writer.comment("Compile source file")
        writer.rule(
            name="CC",
            command="$cc $cflags -MD -c $in -o $outdir",
            depfile="$depfile",
            deps="gcc",
            description="COMPILE $in",
        )
        writer.newline()

        # Link binary
        writer.comment("Link binary")
        writer.rule(
            name="LD",
            command="$ld $in $ldflags",
            description="LINK $name ($pack)",
        )
        writer.newline()

        # Re-run generator script
        writer.comment("Re-run generator script")
        writer.rule(
            name="configure",
            command=f"{sys.executable} {abspath(CONFIGURE_SCRIPT)}",
            description=f"RUN {CONFIGURE_SCRIPT}",
            generator=True,
        )
        writer.newline()

        # Check baserom
        writer.comment("Check baserom")
        writer.rule(
            name="checkrom",
            command=f"{sys.executable} {abspath(CHECKROM_SCRIPT)} --pack=$pack",
            description=f"RUN {CHECKROM_SCRIPT} ($pack)",
        )
        writer.newline()

        # Install Kamek binary
        writer.comment("Install Kamek binary")
        writer.rule(
            name="install_binary",
            command=self._chain_commands([
                "cp -f $bin_in $bin_out",
                "cp -f $map_in $map_out",
            ]),
            description="INSTALL $name ($pack)",
        )
        writer.newline()

        # Install Kamek binary
        writer.comment("Install asset")
        writer.rule(
            name="install_asset",
            command=f"cp -f $in $out",
            description="INSTALL $in ($pack)",
        )
        writer.newline()

        # # Remove all build artifacts
        # writer.comment("Install build artifacts")
        # writer.rule(
        #     name="install",
        #     command=f"cp ",
        #     description=f"INSTALL $pack"
        # )
        # writer.newline()

        # # Safety check!!! rm -rf is very scary :(
        # if (not self.build_dir or isabs(self.build_dir)
        #         or any([c in self.build_dir for c in ('$', '*', '\"')])):
        #     raise ValueError("Build directory path is certainly unsafe for rm")

    def _emit_targets(self, writer: Writer) -> None:
        """Emits the build targets section of the Ninja build script

        Args:
            writer (Writer): Ninja writer
        """

        writer.comment("==================================================")
        writer.comment("Targets")
        writer.comment("==================================================")

        # Re-run generator script
        writer.comment("Re-run generator script")
        writer.build(
            outputs="build.ninja",
            rule="configure",
            implicit=[
                "$configure",
                joinpath("$tools_dir", "ninja_syntax.py"),
                joinpath("$tools_dir", "ninja_kokeshi.py")
            ]
        )
        writer.newline()

        # # Remove all build artifacts
        # writer.comment("Remove all build artifacts")
        # writer.build(
        #     outputs="clean",
        #     rule="phony",
        # )
        # writer.newline()

        # =============================================================================#
        # Loader source code
        loader_units = [CompileUnit(self, file) for file in
                        find_files(self.loader_dir, self.source_extensions)]

        writer.comment("Loader (static) source code")
        for unit in loader_units:
            emit_compile_unit(writer, unit,
                              cflags_var="$cflags_common")
            writer.newline()

        # =============================================================================#
        # Module source code
        library_units = [CompileUnit(self, file) for file in
                         find_files(self.library_dir, self.source_extensions)]

        src_units = [CompileUnit(self, file) for file in
                     find_files(self.src_dir, self.source_extensions)]

        module_units = library_units + src_units

        writer.comment("Module source code")
        for unit in module_units:
            emit_compile_unit(writer, unit,
                              cflags_var="$cflags_common $cflags_module")
            writer.newline()

        # =============================================================================#
        # Linking and installation
        for pack in self.packs:
            # Check baserom
            writer.comment(f"Check baserom ({pack})")
            # writer.build()
            writer.newline()

            # Link Kokeshi loader
            writer.comment(f"Link Kokeshi loader ({pack})")
            loader_obj = KamekLoader(self, pack)
            emit_link_binary(writer, loader_obj, loader_units)
            writer.newline()

            # Link user module
            writer.comment(f"Link user module ({pack})")
            module_obj = KamekModule(self, pack)
            emit_link_binary(writer, module_obj, module_units)
            writer.newline()

            # Install binaries
            writer.comment(f"Install binaries ({pack})")
            emit_install_binary(writer, loader_obj)
            emit_install_binary(writer, module_obj)
            writer.newline()

        # =============================================================================#
        # Project assets
        for pack in self.packs:
            assets = [Asset(self, pack, file)
                      for file in find_files(joinpath(self.assets_dir, pack))]

            # Install assets
            writer.comment(f"Install assets ({pack})")
            for asset in assets:
                emit_install_asset(writer, asset)
            writer.newline()

    def _tool_path(self, name: str) -> str:
        """Creates a relative, platform-agnostic path to an executable in the tools directory

        Args:
            name (str): Tool name (no file extension)

        Returns:
            str: Tool path for the current platform
        """

        path = joinpath(self.tools_dir, name)
        is_windows = sys.platform.startswith("win32")

        if is_windows:
            path = f"{path}{WINDOWS_EXECUTABLE_EXTENSION}"

        return path

    def _win_tool_cmd(self, name: str) -> str:
        """Creates a command to run a Windows executable in the tools directory

        Args:
            name (str): Tool name

        Returns:
            str: Wrapper path
        """

        path = joinpath(self.tools_dir, name)
        is_windows = path.endswith(WINDOWS_EXECUTABLE_EXTENSION)

        if not is_windows:
            return path

        # Windows can run tools natively
        if sys.platform.startswith("win32"):
            return path

        # Mac systems use wine-crossover
        if sys.platform.startswith("darwin"):
            return f"wine {path}"

        # Linux systems use wibo
        if sys.platform.startswith("linux"):
            return f"wibo {path}"

        assert False, f"Unknown platform: {sys.platform}"

    def _chain_commands(self, commands: list[str]) -> str:
        """Creates a single Ninja `command` from multiple shell commands

        Args:
            commands (list[str]): Shell commands to execute

        Returns:
            str: Single command
        """

        command = " && ".join(commands)

        # Windows requires a subshell
        if sys.platform.startswith("win32"):
            command = f"cmd /c {command}"

        return command
